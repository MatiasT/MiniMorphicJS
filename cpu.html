<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>MiniMorphicJS demo</title>
	</head>
	<body style="margin: 0"> 
		<canvas id="world" oncontextmenu="return false"></canvas>
		
		
		<script src="js/core/KeyCode.js"></script>
		<script src="js/core/Canvas.js"></script>
		<script src="js/core/Form.js"></script>
		<script src="js/core/EventHandler.js"></script>
		<script src="js/core/Morph.js"></script>
		<script src="js/core/World.js"></script>
		<script src="js/core/Sprite.js"></script>
		<script src="js/core/Ellipse.js"></script>
		<script src="js/core/StringMorph.js"></script>
		<script src="js/core/Button.js"></script>
		<script src="js/layout/HorizontalView.js"></script>
		<script src="js/layout/VerticalView.js"></script>
		<script src="js/simulation/Process.js"></script>
		<script src="js/simulation/Processor.js"></script>
		<script src="js/simulation/Execution.js"></script>
		  
		
		<script>
		// First we load all the images we're going to use
			var world = new World();
			let vv = new VerticalView();
			vv.color="#222222"; 
			world.addMorph(vv);
			let processes=[];
			let processors = [];
			processes.push( new Process("P1",10,1,1,"red"));
			processes.push( new Process("P2",5,3,3,"blue"));
			processes.push( new Process("P3",20,2,5,"green"));
			processes.push( new Process("P4",3,0,0,"pink"));
			
			processors.push(new Processor("FCFS","Blue",0,(state,time)=>{
				let a = state.filter(p=>p.work>0 && p.arrive<=time);
				a.sort((l,r)=>l.arrive-r.arrive);
				return a.length>0?a[0]:undefined;
			}));
			let lastRR=undefined;
			processors.push(new Processor("RR 1 0","Green",0,
			(state,time)=>{
				let bi=state.indexOf(lastRR) + 1;
				
				for(let i=0;i<state.length;i++){
					let c= state[(i+bi)%state.length];
					if(c.work>0 && c.arrive<=time){
						lastRR=c;
						return c;
					}
				}
				return undefined;
			}));
			let lastRR31=undefined;
			let RR31execs=0;
			processors.push(new Processor("RR 3 1","Orange",1,
			(state,time)=>{
				let bi=state.indexOf(lastRR31) + 1;
				if(lastRR31&&lastRR31.work>0 && RR31execs>0){
					RR31execs--;				
					return lastRR31;
				}
				for(let i=0;i<state.length;i++){
					let c= state[(i+bi)%state.length];
					if(c.work>0 && c.arrive<=time){
						lastRR31=c;
						RR31execs=2;
						return c;
					}
				}
				return undefined;
			}));
			
		   
			 
			
			let sim = new HorizontalView();
			let procNames = new VerticalView();
			let execs= new VerticalView();
			let executions=[];
			
			sim.addMorph(procNames);
			sim.addMorph(execs);
			vv.addMorph(sim);
			processors.forEach(e=>{
				let ex = new Execution(e,processes);
				let name= new StringMorph(e.name);
				name.on("step",()=>{name.height=ex.height;});
				procNames.addMorph(name);
				executions.push(ex);
				execs.addMorph(ex);
			});
		
			
		</script>
	</body>
</html>
